/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BlockDeviceObservation struct {
}

type BlockDeviceParameters struct {

	// +kubebuilder:validation:Optional
	BootIndex *float64 `json:"bootIndex,omitempty" tf:"boot_index,omitempty"`

	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// +kubebuilder:validation:Optional
	DestinationType *string `json:"destinationType,omitempty" tf:"destination_type,omitempty"`

	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	DeviceType *string `json:"deviceType,omitempty" tf:"device_type,omitempty"`

	// +kubebuilder:validation:Optional
	DiskBus *string `json:"diskBus,omitempty" tf:"disk_bus,omitempty"`

	// +kubebuilder:validation:Optional
	GuestFormat *string `json:"guestFormat,omitempty" tf:"guest_format,omitempty"`

	// +kubebuilder:validation:Required
	SourceType *string `json:"sourceType" tf:"source_type,omitempty"`

	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeSize *float64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type InstanceObservation struct {
	AccessIPV4 *string `json:"accessIpV4,omitempty" tf:"access_ip_v4,omitempty"`

	AccessIPV6 *string `json:"accessIpV6,omitempty" tf:"access_ip_v6,omitempty"`

	AllMetadata map[string]*string `json:"allMetadata,omitempty" tf:"all_metadata,omitempty"`

	FloatingIP *string `json:"floatingIp,omitempty" tf:"floating_ip,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Network []NetworkObservation `json:"network,omitempty" tf:"network,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	SystemDiskID *string `json:"systemDiskId,omitempty" tf:"system_disk_id,omitempty"`

	VolumeAttached []VolumeAttachedObservation `json:"volumeAttached,omitempty" tf:"volume_attached,omitempty"`
}

type InstanceParameters struct {

	// +kubebuilder:validation:Optional
	AdminPass *string `json:"adminPass,omitempty" tf:"admin_pass,omitempty"`

	// +kubebuilder:validation:Optional
	AutoRecovery *bool `json:"autoRecovery,omitempty" tf:"auto_recovery,omitempty"`

	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// +kubebuilder:validation:Optional
	BlockDevice []BlockDeviceParameters `json:"blockDevice,omitempty" tf:"block_device,omitempty"`

	// +kubebuilder:validation:Optional
	ConfigDrive *bool `json:"configDrive,omitempty" tf:"config_drive,omitempty"`

	// +kubebuilder:validation:Optional
	FlavorID *string `json:"flavorId,omitempty" tf:"flavor_id,omitempty"`

	// +kubebuilder:validation:Optional
	FlavorName *string `json:"flavorName,omitempty" tf:"flavor_name,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Optional
	ImageName *string `json:"imageName,omitempty" tf:"image_name,omitempty"`

	// +crossplane:generate:reference:type=KeyPair
	// +kubebuilder:validation:Optional
	KeyPair *string `json:"keyPair,omitempty" tf:"key_pair,omitempty"`

	// Reference to a KeyPair to populate keyPair.
	// +kubebuilder:validation:Optional
	KeyPairRef *v1.Reference `json:"keyPairRef,omitempty" tf:"-"`

	// Selector for a KeyPair to populate keyPair.
	// +kubebuilder:validation:Optional
	KeyPairSelector *v1.Selector `json:"keyPairSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Network []NetworkParameters `json:"network,omitempty" tf:"network,omitempty"`

	// +kubebuilder:validation:Optional
	Personality []PersonalityParameters `json:"personality,omitempty" tf:"personality,omitempty"`

	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	SchedulerHints []SchedulerHintsParameters `json:"schedulerHints,omitempty" tf:"scheduler_hints,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	StopBeforeDestroy *bool `json:"stopBeforeDestroy,omitempty" tf:"stop_before_destroy,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`
}

type NetworkObservation struct {
	Mac *string `json:"mac,omitempty" tf:"mac,omitempty"`
}

type NetworkParameters struct {

	// +kubebuilder:validation:Optional
	AccessNetwork *bool `json:"accessNetwork,omitempty" tf:"access_network,omitempty"`

	// +kubebuilder:validation:Optional
	FixedIPV4 *string `json:"fixedIpV4,omitempty" tf:"fixed_ip_v4,omitempty"`

	// +kubebuilder:validation:Optional
	FixedIPV6 *string `json:"fixedIpV6,omitempty" tf:"fixed_ip_v6,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Port *string `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type PersonalityObservation struct {
}

type PersonalityParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Required
	File *string `json:"file" tf:"file,omitempty"`
}

type SchedulerHintsObservation struct {
}

type SchedulerHintsParameters struct {

	// +kubebuilder:validation:Optional
	BuildNearHostIP *string `json:"buildNearHostIp,omitempty" tf:"build_near_host_ip,omitempty"`

	// +kubebuilder:validation:Optional
	DehID *string `json:"dehId,omitempty" tf:"deh_id,omitempty"`

	// +kubebuilder:validation:Optional
	DifferentHost []*string `json:"differentHost,omitempty" tf:"different_host,omitempty"`

	// +kubebuilder:validation:Optional
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// +kubebuilder:validation:Optional
	Query []*string `json:"query,omitempty" tf:"query,omitempty"`

	// +kubebuilder:validation:Optional
	SameHost []*string `json:"sameHost,omitempty" tf:"same_host,omitempty"`

	// +kubebuilder:validation:Optional
	TargetCell *string `json:"targetCell,omitempty" tf:"target_cell,omitempty"`

	// +kubebuilder:validation:Optional
	Tenancy *string `json:"tenancy,omitempty" tf:"tenancy,omitempty"`
}

type VolumeAttachedObservation struct {
	BootIndex *float64 `json:"bootIndex,omitempty" tf:"boot_index,omitempty"`

	PciAddress *string `json:"pciAddress,omitempty" tf:"pci_address,omitempty"`

	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type VolumeAttachedParameters struct {
}

// InstanceSpec defines the desired state of Instance
type InstanceSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     InstanceParameters `json:"forProvider"`
}

// InstanceStatus defines the observed state of Instance.
type InstanceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        InstanceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Instance is the Schema for the Instances API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,flexibleengine}
type Instance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              InstanceSpec   `json:"spec"`
	Status            InstanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// InstanceList contains a list of Instances
type InstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Instance `json:"items"`
}

// Repository type metadata.
var (
	Instance_Kind             = "Instance"
	Instance_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Instance_Kind}.String()
	Instance_KindAPIVersion   = Instance_Kind + "." + CRDGroupVersion.String()
	Instance_GroupVersionKind = CRDGroupVersion.WithKind(Instance_Kind)
)

func init() {
	SchemeBuilder.Register(&Instance{}, &InstanceList{})
}
